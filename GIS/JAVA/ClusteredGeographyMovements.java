package GIS.JAVA;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

import GIS.JAVA.GeographyMovement.Pos;
import GIS.JAVA.MapPlot.GeoPerson;

//WARNING: Depends on "GIS/source/map_plots.csv" generated by GeographyMovement.java
public class ClusteredGeographyMovements {
	static HashMap<Integer, GeoPerson> mapPlots;
	private static final String  SRC = "GIS/source/map_plots.csv";
	private final static String SRC_GEO = "GIS/source/studios_geo_src.csv";
	private static final String CLU_MOV_EDGES_TAR = "GIS/statistics/edges-clustered_movements.csv", CLU_MOV_NODES_TAR = "GIS/statistics/nodes-clustered_movements.csv";
	//Works similarly to the one in GeographyMovement.java
	private static final boolean APPLY_INERT = true;
	//Enable this to count the movements between two locations in all years together as weight
	private static final boolean CLUSTER_YEARS = true;
	//Whether latitudes and lontitudes should be written on the node list
	private static final boolean WRITE_GEO = true;

	protected static final double RANDOM_OFFSET = 3.0;

	private static HashMap<String, Pos> geoCatToPos = new HashMap<String, Pos>();
	
	public static void main(String[] args) {
		try {
			initAllMapPlots();
			generateClusteredGeographyMovementCSV();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private static void generateClusteredGeographyMovementCSV() throws IOException {
		//Store geographical movement formatted as a String like "START-DESTINATION:STAR_YEAR-DEST_YEAR" and 
		//assign it with the count of such movements in this map
		HashMap<String, Integer> clusterAndCountMap = new HashMap<String, Integer>();

		for (GeoPerson p : mapPlots.values()) {
			if(!APPLY_INERT) {
				int year = p.debutYear;
				String next[] = p.appearances.get(year).getMainCategory();
				String prev[] = next;
				int prevYear = year;
				year++;

				if(year > p.lastAppearance) {
					//If this person only appeared in one year, this person cannot make any movements, so skip
					continue;
				}

				for (; year <= p.lastAppearance; year++) {
					next = p.appearances.get(year).getMainCategory();
					if(next.length <= 0) {
						//If this person did not appear in this year, skip this year and keep the previous location and year
						continue;
					}
					//Compare if the loactions are the same
					String[] sortedNext = next.clone();
					Arrays.sort(sortedNext);
					String[] sortedPrev = prev.clone();
					Arrays.sort(sortedPrev);
					if(Arrays.equals(sortedNext, sortedPrev)) {
						//If the locations are the same, skip this year and keep the previous location and year
						prevYear = year;
						continue;
					}
					ClusteredMovement mov = new ClusteredMovement(prev, next, prevYear, year);
					String tag = mov.toString();
					clusterAndCountMap.put(tag, clusterAndCountMap.getOrDefault(tag, 0) + 1);
					prev = next;
					prevYear = year;
				}
			} else {
				//This is different from the "prev[]" above, as
				//it only stores the locations that are kept after applying inert filter
				ArrayList<String> prevLocs = new ArrayList<String>();

				int year = p.debutYear;
				String next[] = p.appearances.get(year).getMainCategory();
				for(String loc : next) {
					prevLocs.add(loc);
				}
				int prevYear = year;
				year++;

				if(year > p.lastAppearance) {
					//If this person only appeared in one year, this person cannot make any movements, so skip
					continue;
				}

				for (; year <= p.lastAppearance; year++) {
					next = p.appearances.get(year).getMainCategory();

					if(next.length <= 0) {
						//If this person did not appear in this year, skip this year and keep the previous location and year

						continue;
					}else{
						//Locations with inert decides the locations that are kept after applying inert filter
						ArrayList<String> locationsWithInert = new ArrayList<String>();
						for (String string : next) {
							if(prevLocs.contains(string)) {
								locationsWithInert.add(string);
							}
						}

						if(locationsWithInert.size() <= 0) {
							//Force to update location because no inert location can be found
							//In this case the new locations can be directly added to locationsWithInert
							for (String string : next) {
								locationsWithInert.add(string);
							}
						}

						//Compare if the loactions are the same
						String[] sortedNext = locationsWithInert.toArray(new String[locationsWithInert.size()]);
						Arrays.sort(sortedNext);
						String[] sortedPrev = prevLocs.toArray(new String[prevLocs.size()]);
						Arrays.sort(sortedPrev);
						if(Arrays.equals(sortedNext, sortedPrev)) {
							//If the locations are the same, skip this location and update year
							prevYear = year;
							continue;
						}

						//Write to map
						ClusteredMovement mov = new ClusteredMovement(prevLocs.toArray(
							new String[prevLocs.size()]), locationsWithInert.toArray(new String[locationsWithInert.size()]),
							prevYear, year);
						
						if(mov.startCat.isEmpty() || mov.destCat.isEmpty()) {
							System.out.println("Empty start or destination category: ");
							for (String string : prevLocs) {
								System.out.println(string + "->");
							}
							for (String string : next) {
								System.out.println("->" + string);
							}
							System.in.read();
						}

						String tag = mov.toString();
						clusterAndCountMap.put(tag, clusterAndCountMap.getOrDefault(tag, 0) + 1);

						//Update previvous locations
						prevLocs.clear();
						for(String loc : locationsWithInert) {
							prevLocs.add(loc);
						}
						prevYear = year;
					}
				}
			}
		}

		//Convert the map to a list of ClusteredMovement
		ArrayList<ClusteredMovement> clusteredMovements = new ArrayList<ClusteredMovement>();
		//Use this to store the nodes information of each cluster
		HashMap<String, Integer> clusteredRegions = new HashMap<String, Integer>();
		int id = 0;

		for (String tag : clusterAndCountMap.keySet()) {
			ClusteredMovement mov = new ClusteredMovement(tag);
			mov.count = clusterAndCountMap.get(tag);
			if(!clusteredRegions.containsKey(mov.startCat)) {
				clusteredRegions.put(mov.startCat, id);
				id++;
			}
			if(!clusteredRegions.containsKey(mov.destCat)) {
				clusteredRegions.put(mov.destCat, id);
				id++;
			}
			clusteredMovements.add(mov);
		}

		//Write edges to file
		if(!CLUSTER_YEARS) {
			BufferedWriter writer = new BufferedWriter(new FileWriter(CLU_MOV_EDGES_TAR));
			writer.write("Source,Target,Weight,SourceName,TargetName,StartYear,EndYear\n");
			for (ClusteredMovement mov : clusteredMovements) {
				writer.write(clusteredRegions.get(mov.startCat) + ","
				+ clusteredRegions.get(mov.destCat) + "," + mov.count + ",\"" +
				mov.startCat + "\",\"" + mov.destCat + "\"," +
				mov.startYear + "," + mov.destYear + "\n");
			}
			writer.close();
		} else {
			//This map ignores year ranges and use String like "START-DESTINATION" as key
			HashMap<String, Integer> clusterAndCountMap2 = new HashMap<String, Integer>();
			for (ClusteredMovement mov : clusteredMovements) {
				//Merge all movements between two regions in different years together
				String tag = mov.startCat + "-" + mov.destCat;
				clusterAndCountMap2.put(tag, clusterAndCountMap2.getOrDefault(tag, 0) + mov.count);
			}
			BufferedWriter writer = new BufferedWriter(new FileWriter(CLU_MOV_EDGES_TAR.substring(0, CLU_MOV_EDGES_TAR.length() - 4) + "(all_years).csv"));
			writer.write("Source,Target,Weight,SourceName,TargetName\n");
			for (String tag : clusterAndCountMap2.keySet()) {
				String[] regions = tag.split("-");
				writer.write(clusteredRegions.get(regions[0]) + ","
				+ clusteredRegions.get(regions[1]) + "," + clusterAndCountMap2.get(tag) + ",\"" +
				regions[0] + "\",\"" + regions[1] + "\"\n");
			}
			writer.close();
		}

		//Write nodes info to file
		BufferedWriter writer2 = new BufferedWriter(new FileWriter(CLU_MOV_NODES_TAR));
		writer2.write(WRITE_GEO ? "Id,Label,lat,lon\n" : "Id,Label\n");
		for (String region : clusteredRegions.keySet()) {
			writer2.write(clusteredRegions.get(region) + "," + region);
			if(!WRITE_GEO) {
				writer2.newLine();
			}else{
				Pos p = getGeoLocForNode(region);
				writer2.write("," + p.lat + "," + p.lon + "\n");
			}
		}
		writer2.close();
	}

	private static Pos getGeoLocForNode(String region) throws IOException {
		ArrayList<Pos> locs = new ArrayList<Pos>();
		String[] cats = region.split(" & ");
		Pos pos = new Pos(0, 0);
		for (String c : cats) {
			if(geoCatToPos.containsKey(c)) {
				Pos p = geoCatToPos.get(c);
				locs.add(p);
			}else{
				System.out.println(geoCatToPos.get("Gansu"));
				throw new RuntimeException("No location found for " + c);
			}
		}
		if(locs.size() == 3) {
			pos = Pos.getMiddlePoint(locs.get(0), locs.get(1), locs.get(2));
		}else if(locs.size() == 2) {
			pos = Pos.getMiddlePoint(locs.get(0), locs.get(1));
		}else if(locs.size() == 1) {
			pos = locs.get(0);
		}else{
			throw new RuntimeException("Cannot locate " + region);
		}

		return pos;
	}

	private static void initAllMapPlots() throws IOException {
		File geoSrc = new File(SRC_GEO);
		BufferedReader br = new BufferedReader(new FileReader(geoSrc));
		String line1 = br.readLine();
		while ((line1 = br.readLine()) != null) {
			String[] geo = line1.split(",");
			geoCatToPos.put(geo[1], new Pos(Double.parseDouble(geo[2]), Double.parseDouble(geo[3])));
		}
		br.close();
		
		mapPlots = new HashMap<Integer, GeoPerson>();
		File nodeFile = new File(SRC);
		int lineNum = GeographyMovement.getFileLineNumber(nodeFile);
		BufferedReader reader = new BufferedReader(new FileReader(nodeFile));
		String line = reader.readLine();
		int n = 0;
		while((line = reader.readLine()) != null) {
			System.out.println("Initing map plots: " + (n) + "/" + lineNum);
			n++;

			String[] lineSplit = line.split(",", -1);
			String name = lineSplit[1];
			int id = Integer.parseInt(lineSplit[0]);
			int debutYear = Integer.parseInt(lineSplit[2]);
			int endYear = Integer.parseInt(lineSplit[3]);
			boolean fromPrivateStudio = lineSplit[4].equalsIgnoreCase("true");
			mapPlots.put(id, new GeoPerson(id, name, debutYear, endYear, fromPrivateStudio, lineSplit[5]));

			for(int col=6; col<24; col++) {
				int year = col + 1943;
				String app = lineSplit[col];
				if(!app.isBlank()) {
					String[] apps = app.split(" & ");
					for (String string : apps) {
						int count = Integer.parseInt(string.substring(string.lastIndexOf("[") + 1, string.lastIndexOf("]")));
						String cat = string.substring(0, string.lastIndexOf("[")).trim();
						mapPlots.get(id).addAffiliationCategory(cat, year, count);
					}
				}
			}
		}
		reader.close();
	}
}

class ClusteredMovement {
	String startCat, destCat;
	int startYear, destYear;
	//Only used in writing to file
	int count = -1;
	
	public ClusteredMovement(String startCat, String destCat, int startYear, int destYear) {
		this.startCat = startCat;
		this.destCat = destCat;
		this.destYear = destYear;
		this.startYear = startYear;
	}

	public ClusteredMovement(String[] prevYearCats, String[] nextYearCats, int startYear, int destYear) {
		//Convert the two String arrays to two String formatted like "LOCATION 1 & LOCATION 2 & LOCATION 3..."
		String prev = "", next = "";
		for (String string : prevYearCats) {
			prev += string + " & ";
		}
		for (String string : nextYearCats) {
			next += string + " & ";
		}
		if(prevYearCats.length > 0) prev = prev.substring(0, prev.length() - 3);
		if(nextYearCats.length > 0) next = next.substring(0, next.length() - 3);

		this.startCat = prev;
		this.destCat = next;
		if(this.startCat.equals(this.destCat)) throw new RuntimeException("Start and dest are the same: " + this.startCat);
		this.startYear = startYear;
		this.destYear = destYear;
	}

	public ClusteredMovement(String formattedString) {
		String[] split = formattedString.split(":");
		String[] locs = split[0].split("-");
		String[] years = split[1].split("-");
		this.startCat = locs[0];
		this.destCat = locs[1];
		this.startYear = Integer.parseInt(years[0]);
		this.destYear = Integer.parseInt(years[1]);
	}
	
	@Override
	public String toString() {
		return startCat + "-" + destCat + ":" + startYear + "-" + destYear;
	}
}